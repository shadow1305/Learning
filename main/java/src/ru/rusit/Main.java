/*
 * Тема:
 * Структуры данных
 *
 * С массивами, что были разобраны в предыдущем задании, работать зачастую очень неудобно, потому в Java есть более продвинутые структуры данных. По сути все, что будет
 * объяснено здесь и в задании, будет той же работой с массивами, но на более высоком уровне.
 *
 * Структуры данных разделяются на коллекции и карты (Collection, Map). Коллекции подразделяются на наборы и списки (Set, List). О всех трех (набор, список, карта) и пойдет речь.
 * Список - упорядоченный набор данных. По умолчанию порядок определяется очередностью добавления элементов в список. Каждый элемент имеет свой индекс. К спискам относятся классы:
 *
 * ArrayList<Object> - массив. Доступ к элементам по индексу. Быстро работает получение элемента, долго работает добавление.
 * LinkedList<Object> - связанный список. Доступ к элементам по последнему выбранному. Быстро работает добавление, долго работает получение (кроме первого и последнего элемента).
 * Queue<Object> - очередь, построенная по принципу "первый пришел - первый ушел". Доступ к элементам в порядке добавления.
 * Dequeue<Object> - очередь, построенная по принципе "последний пришел - первый ушел". Доступ к элементам в порядке, обратнорм добавлению.
 *
 * Наверняка приковало к себе внимание название класса в угловых (< >) скобках. Здесь указывается, какой конкретно тип данных используется в списке. Указывать этот объект не
 * обязательно, но крайне желательно, чтобы избежать явного приведения типов и возможности отправить в список элемент, который к списку не может иметь отношения (что
 * предотвращает возможные ошибки приведения типов). Начиная к Java 7, название типа списка необходимо указывать только в левой части объявления списка:
 *
 * ArrayList<Dog> dogs = new ArrayList<>();
 *
 * Набор - неупорядоченный набор данных. Нет доступа по индексу, можно работать только со всем набором данных сразу.
 * HashSet<Object> - набор основанный на хеш-коде значения. Хеш-код - значение, выдаваемое в результате работы хеш-функции, определенной типом элементов, хранящихся в нем.
 * Правильно реализованная хеш-функция гарантирует уникальность элементов в наборе. Добавление/извлечение данных из такого набора моментально.
 * TreeSet<Object> - сортированный набор. Сортировка идет при каждом изменении набора. Добавление может происходить долго.
 * LinkedHashSet<Object> - сортированный набор, основанный на хеш-коде. Нечто среднее между HashSet и TreeSet.
 *
 * Принцип работы с набором (применим относительно любых коллекций):
 * 1 вариант работы: В предыдущем уроке я упоминал о цикле перебором. Здесь он как раз и применим:
 * Set<Integer> numbers = new HashSet<>(); // Объявление набора.
 * numbers.add(1); // Добавление элемента в набор.
 * for (Integer number : numbers) {
 *      // Делаем что хотим. number содержит в себе ссылку на элемент набора. Но! При таком подходе НЕЛЬЗЯ удалять элементы из набора.
 * }
 *
 * 2 вариант работы: объект под названием итератор. Итератор - объект, содержащий ссылку на текущий и следующий (Iterator), и предыдущий (ListIterator) элемент набора.
 * Set<Integer> numbers = new HashSet<>(); // Объявление набора.
 * Iterator<Integer> numbersIterator = numbers.iterator(); // Получение итератора.
 * while (numbersIterator.hasNext()) { // Если на следущей позиции есть элемент
 *      Integer number = numbersIterator.next(); // сдвигаем позицию на этот элемент и получаем его.
 *
 *      // Делаем что хотим, вплоть до удаления текущего элемента из набора.
 *
 *      numbersIterator.remove(); // удаление текущего элемента из набора (если требуется).
 * }
 */

package ru.rusit;

public class Main {

    public static void main(String[] args) {
    }
}
